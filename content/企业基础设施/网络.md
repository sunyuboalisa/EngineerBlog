## 信任网络模型

基于CA的认证体系

  

## 网络划分

```

  

```

## Nginx
先创建一个nginx文件夹，然后创建docker compose.yaml 和 nginx.conf
docker compose.yaml 文件内容

```  
services:
  nginx:
    image: docker.1ms.run/library/nginx
    container_name: nginx
    network_mode: host # 建议用 host 模式，要不然要映射很多监听的端口
    restart: unless-stopped
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf  # 挂载自定义配置文件
      - ./html:/usr/share/nginx/html        # 挂载静态文件目录
      - ./logs:/var/log/nginx               # 挂载日志目录
      - ./ssl:/etc/nginx/ssl                # （可选）挂载SSL证书
    environment:
      - TZ=Asia/Shanghai                    # 时区设置

```

挂载的文件，添加一个nginx.conf就够了，内容如下
```
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    tcp_nopush      on;
    keepalive_timeout  65;
    client_max_body_size 0;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;

    # 主服务配置 一些使用反向代理的例子
    server {
        listen       80;
        server_name  localhost;

        location /sftp {
            proxy_pass http://127.0.0.1:8080/sftp;  # 必须保留 /sftp/
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            client_max_body_size 2G;
            proxy_request_buffering off;
        }

        location /webdav {
            proxy_pass http://127.0.0.1:8090;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Depth $http_depth;
            proxy_set_header Overwrite $http_overwrite;
            client_max_body_size 10G;
            proxy_request_buffering off;
        }

        location / {
            root   /usr/share/nginx/html;
            index  index.html;
        }
    }

    # HTTPS配置
    server {
        listen       443 ;
        server_name  localhost;
        #ssl_certificate     /etc/nginx/ssl/cert.pem;
        #ssl_certificate_key /etc/nginx/ssl/key.pem;

        location /sftp {
            proxy_pass http://127.0.0.1:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            client_max_body_size 2G;
            proxy_request_buffering off;
        }

        location /webdav {
            proxy_pass http://127.0.0.1:8090;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Depth $http_depth;
            proxy_set_header Overwrite $http_overwrite;
            client_max_body_size 10G;
            proxy_request_buffering off;
        }
    }
}

```
准备好之后直接运行
```
docker compose up -d  
```

## DNS

基于 dnsmasq 搭建 dns 服务器

```
docker run \ --name dnsmasq \ -d \ -p 53:53/udp \ -p 5380:8080 \ -v /opt/dnsmasq.conf:/etc/dnsmasq.conf \ --log-opt "max-size=100m" \ -e "HTTP_USER=foo" \ -e "HTTP_PASS=bar" \ --restart always \ jpillora/dnsmasq

```

运行后直接打开网站 http://domain:5380, 之后可以在上面直接配置域名。
客户端使用的时候，给网络配置下 `dns` 服务器参数，指向该 `domain`

## PKI

基于step-ca搭建PKI，启用ACME协议。

```

  

```

## SFTP
可以用开源的sftpgo，先创建一个 sftp文件夹，然后再sftp文件夹下面创建config 和 data 文件夹，并在 config 中放置默认的sftpgo.json配置文件，最后在sftp目录下创建docker compose.yaml文件
```
将config 和 data文件owner设置成1100
sudo chown -R 1100:1100 config
sudo chown -R 1100:1100 data
```

```
services:
  sftpgo:
    image: docker.1ms.run/drakkan/sftpgo:latest
    container_name: sftpgo
    user: "1100:1100"
    restart: unless-stopped
    ports:
      - "8080:8080"    # Web管理界面和API
      - "2022:2022"    # SFTP端口
      - "8090:10080"  # WebDAV端口
    volumes:
      - "./data:/srv/sftpgo"
      - "./config:/var/lib/sftpgo"
      - "./config/sftpgo.json:/etc/sftpgo/sftpgo.json"
```

最后执行 `docker compose up -d`